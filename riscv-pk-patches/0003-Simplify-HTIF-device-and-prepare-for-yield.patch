From a8b8ba661e5648b68107b30df01429cf4fea0d67 Mon Sep 17 00:00:00 2001
From: Diego Nehab <diego@cartesi.io>
Date: Sun, 15 Mar 2020 00:28:35 -0300
Subject: [PATCH 3/3] Simplify HTIF device and prepare for yield

---
 machine/htif.c  | 99 ++++++++++++-------------------------------------
 machine/htif.h  | 21 +++++------
 machine/mcall.h |  6 +++
 machine/mtrap.c |  8 ++++
 4 files changed, 47 insertions(+), 87 deletions(-)

diff --git a/machine/htif.c b/machine/htif.c
index 9cd53ec..29a73b3 100644
--- a/machine/htif.c
+++ b/machine/htif.c
@@ -9,7 +9,6 @@
 
 volatile uint64_t *tohost;
 volatile uint64_t *fromhost;
-volatile int htif_console_buf = 0;
 uintptr_t htif;
 static spinlock_t htif_lock = SPINLOCK_INIT;
 
@@ -19,98 +18,46 @@ static spinlock_t htif_lock = SPINLOCK_INIT;
 #define TOHOST(base_int)	(uint64_t *)(base_int + TOHOST_OFFSET)
 #define FROMHOST(base_int)	(uint64_t *)(base_int + FROMHOST_OFFSET)
 
-static void __check_fromhost()
-{
-  uint64_t fh = *fromhost;
-  if (!fh)
-    return;
-  *fromhost = 0;
-
-  // this should be from the console
-  assert(FROMHOST_DEV(fh) == 1);
-  switch (FROMHOST_CMD(fh)) {
-    case 0:
-      htif_console_buf = 1 + (uint8_t)FROMHOST_DATA(fh);
-      break;
-    case 1:
-      break;
-    default:
-      assert(0);
-  }
-}
-
-static void __set_tohost(uintptr_t dev, uintptr_t cmd, uintptr_t data)
-{
-  while (*tohost)
-    __check_fromhost();
-  *tohost = TOHOST_CMD(dev, cmd, data);
-}
-
 int htif_console_getchar()
 {
-#if __riscv_xlen == 32
-  // HTIF devices are not supported on RV32
-  return -1;
-#endif
-
   spinlock_lock(&htif_lock);
-    __check_fromhost();
-    int ch = htif_console_buf;
-    if (ch >= 0) {
-      htif_console_buf = -1;
-      __set_tohost(1, 0, 0);
-    }
+  *fromhost = 0;
+  *tohost = TOHOST_DEV_CMD_DATA(1, 0, 0);
+  uint64_t ack = *fromhost;
   spinlock_unlock(&htif_lock);
-
-  return ch - 1;
+  return (int)(FROMHOST_DATA(ack))-1;
 }
 
-static void do_tohost_fromhost(uintptr_t dev, uintptr_t cmd, uintptr_t data)
+void htif_console_putchar(uint8_t ch)
 {
   spinlock_lock(&htif_lock);
-    __set_tohost(dev, cmd, data);
-
-    while (1) {
-      uint64_t fh = *fromhost;
-      if (fh) {
-        if (FROMHOST_DEV(fh) == dev && FROMHOST_CMD(fh) == cmd) {
-          *fromhost = 0;
-          break;
-        }
-        __check_fromhost();
-      }
-    }
+  *fromhost = 0;
+  *tohost = TOHOST_DEV_CMD_DATA(1, 1, ch);
+  uint64_t ack = *fromhost;
+  (void) ack; /* no need for info in ack */
   spinlock_unlock(&htif_lock);
 }
 
-void htif_syscall(uintptr_t arg)
+void htif_poweroff(void)
 {
-  do_tohost_fromhost(0, 0, arg);
+  while (1) {
+    spinlock_lock(&htif_lock);
+    *fromhost = 0;
+    *tohost = TOHOST_DEV_CMD_DATA(0, 0, 1); /* does not return */
+    uint64_t ack = *fromhost;
+    (void) ack;
+    spinlock_unlock(&htif_lock);
+  }
 }
 
-void htif_console_putchar(uint8_t ch)
+uint64_t htif_yield(uint64_t cmd_data)
 {
-#if __riscv_xlen == 32
-  // HTIF devices are not supported on RV32, so proxy a write system call
-  volatile uint64_t magic_mem[8];
-  magic_mem[0] = SYS_write;
-  magic_mem[1] = 1;
-  magic_mem[2] = (uintptr_t)&ch;
-  magic_mem[3] = 1;
-  do_tohost_fromhost(0, 0, (uintptr_t)magic_mem);
-#else
   spinlock_lock(&htif_lock);
-    __set_tohost(1, 1, ch);
+  *fromhost = 0;
+  *tohost = TOHOST_DEV(2) | TOHOST_CMD_DATA(cmd_data);
+  uint64_t ack = *fromhost;
   spinlock_unlock(&htif_lock);
-#endif
-}
-
-void htif_poweroff()
-{
-  while (1) {
-    *fromhost = 0;
-    *tohost = 1;
-  }
+  return ack;
 }
 
 struct htif_scan
diff --git a/machine/htif.h b/machine/htif.h
index a4e5e8e..1fb8797 100644
--- a/machine/htif.h
+++ b/machine/htif.h
@@ -5,14 +5,13 @@
 
 #include <stdint.h>
 
-#if __riscv_xlen == 64
-# define TOHOST_CMD(dev, cmd, payload) \
-  (((uint64_t)(dev) << 56) | ((uint64_t)(cmd) << 48) | (uint64_t)(payload))
-#else
-# define TOHOST_CMD(dev, cmd, payload) ({ \
-  if ((dev) || (cmd)) __builtin_trap(); \
-  (payload); })
-#endif
+#define TOHOST_DEV(dev) ((uint64_t)(dev) << 56)
+#define TOHOST_CMD(cmd) ((uint64_t)(cmd) << 56 >> 8)
+#define TOHOST_DATA(cmd) ((uint64_t)(cmd) << 16 >> 16)
+#define TOHOST_CMD_DATA(cmd_data) (cmd_data << 8 >> 8)
+#define TOHOST_DEV_CMD_DATA(dev, cmd, data) \
+  (TOHOST_DEV(dev) | TOHOST_CMD(cmd) | TOHOST_DATA(data))
+
 #define FROMHOST_DEV(fromhost_value) ((uint64_t)(fromhost_value) >> 56)
 #define FROMHOST_CMD(fromhost_value) ((uint64_t)(fromhost_value) << 8 >> 56)
 #define FROMHOST_DATA(fromhost_value) ((uint64_t)(fromhost_value) << 16 >> 16)
@@ -20,8 +19,8 @@
 extern uintptr_t htif;
 void query_htif(uintptr_t dtb);
 void htif_console_putchar(uint8_t);
-int htif_console_getchar();
-void htif_poweroff() __attribute__((noreturn));
-void htif_syscall(uintptr_t);
+int htif_console_getchar(void);
+void htif_poweroff(void) __attribute__((noreturn));
+uint64_t htif_yield(uint64_t cmd_data);
 
 #endif
diff --git a/machine/mcall.h b/machine/mcall.h
index 008179f..0f98e9a 100644
--- a/machine/mcall.h
+++ b/machine/mcall.h
@@ -12,5 +12,11 @@
 #define SBI_REMOTE_SFENCE_VMA 6
 #define SBI_REMOTE_SFENCE_VMA_ASID 7
 #define SBI_SHUTDOWN 8
+/* ??D this slot is marked reserved in the legacy SBI extension
+ * (see https://github.com/riscv/riscv-sbi-doc/blob/master/riscv-sbi.adoc)
+ * If we were using a more recent SBI implementation, we could define a
+ * vendor specific extension. Since we are using BBL, we simply take
+ * one of the reserved extension ids in the legacy SBI extension. */
+#define SBI_YIELD 9 
 
 #endif
diff --git a/machine/mtrap.c b/machine/mtrap.c
index 99f98db..1ff6194 100644
--- a/machine/mtrap.c
+++ b/machine/mtrap.c
@@ -63,6 +63,11 @@ static void send_ipi(uintptr_t recipient, int event)
   *OTHER_HLS(recipient)->ipi = 1;
 }
 
+static uint64_t mcall_yield(uint64_t cmd_data)
+{
+    return htif_yield(cmd_data);
+}
+
 static uintptr_t mcall_console_getchar()
 {
   if (uart) {
@@ -157,6 +162,9 @@ send_ipi:
     case SBI_SHUTDOWN:
       retval = mcall_shutdown();
       break;
+    case SBI_YIELD:
+      retval = mcall_yield(arg0);
+      break;
     case SBI_SET_TIMER:
 #if __riscv_xlen == 32
       retval = mcall_set_timer(arg0 + ((uint64_t)arg1 << 32));
-- 
2.24.1

